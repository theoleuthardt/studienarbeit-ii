\chapter{Algorithmen}\label{algorithmen}

% Dieses Kapitel basiert auf der Analyse des Projektquellcodes in \texttt{source/network-interaction}.
\section{Implementierungsübersicht}
Die implementatorische Trennung erfolgt in eine darstellende Komponente, die eine grafische Benutzeroberfläche bereitstellt, und eine serverseitige Komponente, die die Netzwerkläufigkeit und Zustandsverwaltung verantwortet. Die Kommunikation zwischen beiden Komponenten erfolgt über einen periodisch versendeten JSON-Zustand (\texttt{QueueState}) sowie über Steuerkanäle zur Einleitung von Verbindungsversuchen.

\section{Portreservierungsalgorithmus}
Beim Start des Programms wird ein verfügbarer TCP-Port im Bereich \texttt{50500--50600} gesucht und für die Laufzeit reserviert. Die im Quellcode vorhandene Funktion \texttt{FindAvailablePort(startPort, endPort)} prüft die Ports linear (aufsteigend) und versucht für jeden Port, einen Listener zu binden. Der erste Port, bei dem das Binden gelingt, wird als verfügbar erkannt und seine Portnummer zurückgegeben; dieser Port wird vom Programm als eigener Laufzeitport verwendet.

\begin{lstlisting}[style=golang, caption={Portreservierung (Code wie im Repository)}]
func FindAvailablePort(startPort, endPort int) int {
	for port := startPort; port < endPort; port++ {
		listener, err := net.Listen("tcp", fmt.Sprintf(":%d", port))
		if err == nil {
			listener.Close()
			return port
		}
	}
	return endPort
}
\end{lstlisting}

\section{Discovery-Protokoll}
Die Peer-Erkennung basiert auf einem aktiven Scan über einen vordefinierten Portbereich (Standard: 50500--50600). Für jeden Port werden Prüfungen sowohl lokal (loopback) als auch im /24-Subnetz durchgeführt. Die zentrale Prüfroutine ist in \texttt{utils.IsPeerDiscoverable} implementiert und folgt dem Ablauf: Aufbau einer kurzlebigen TCP-Verbindung mit zeitlicher Begrenzung (Timeout), Senden einer kurzen Anwendungsschicht-Nachricht \texttt{DISCOVER\_SYN} und Auswertung der erwarteten Antwort \texttt{DISCOVER\_ACK}. Dieser Anwendungsschicht-Handshake wurde gewählt, weil er die Verlässlichkeit der Erkennung erhöht (die Antwort \texttt{DISCOVER\_ACK} bestätigt explizit die Präsenz der erwarteten Anwendung und reduziert damit Fehlalarme), weil durch kurze Schreib-/Leseoperationen mit restriktiven Timeouts eine effiziente Validierung möglich ist, bevor aufwendigere oder ressourcenintensive Maßnahmen ausgelöst werden, und weil in Netzwerken mit Paketfiltern oder NAT application-layer-Anfragen verlässlichere Aussagen über die Erreichbarkeit der gewünschten Anwendung erlauben.

Die folgende Abbildung \ref{fig:discover-flow} veranschaulicht den schematischen Ablauf der Prüfroutine.

\begin{figure}[H]
\centering
\begin{tikzpicture}[node distance=12mm, every node/.style={font=\small}, align=center]
  \tikzstyle{startstop} = [rectangle, rounded corners, draw=black!60, fill=black!5, text width=38mm, text centered, minimum height=6mm]
  \tikzstyle{process} = [rectangle, draw=black!60, fill=black!10, text width=40mm, text centered, minimum height=6mm]
  \tikzstyle{decision} = [diamond, aspect=2, draw=black!60, fill=black!5, text width=26mm, text centered, inner sep=1pt]
  \tikzstyle{arrow} = [-{Stealth[length=3mm,width=2mm]}, thick]

  \node[startstop] (start) {Start};
  \node[process, below=of start] (dial) {TCP-Verbindung mit \texttt{DialTimeout}};
  \node[process, below=of dial] (send) {Sende \texttt{DISCOVER\_SYN}};
  \node[process, below=of send] (read) {Warte auf Antwort};
  \node[decision, below=of read] (check) {Antwort \texttt{DISCOVER\_ACK}?};
  \node[startstop, below=of check] (add) {Peer speichern};
  \node[startstop, right=of check, xshift=12mm] (discard) {Ignorieren};

  \draw[arrow] (start) -- (dial);
  \draw[arrow] (dial) -- (send);
  \draw[arrow] (send) -- (read);
  \draw[arrow] (read) -- (check);
  \draw[arrow] (check) -- node[right]{ja} (add);
  \draw[arrow] (check) -- node[above]{nein} (discard);
\end{tikzpicture}
\caption{Schematischer Ablauf der Peer-Prüfung in \texttt{utils.IsPeerDiscoverable}}
\label{fig:discover-flow}
\end{figure}

\Needspace{12\baselineskip}
\begin{lstlisting}[style=golang, caption={Peer-Discovery (vereinfacht, sequentiell)}]
func DiscoverPeersSimple(serverPort int, portRange []int) []string {
	var peers []string
	// Produktivcode parallelisiert, hier vereinfacht
	for _, port := range portRange { 
		if port == serverPort {
			continue
		}
		addr := fmt.Sprintf("127.0.0.1:%d", port)
		if IsPeerDiscoverable(addr) {
			peers = append(peers, addr)
		}
	}
	return peers
}
\end{lstlisting}

\section{Verbindungsaufbau}
Der Verbindungsaufbau erfolgt über die Nachricht \texttt{CONNECT\_REQ:ip:port}. Der Nutzer wählt einen Peer aus der zuvor ermittelten Liste (siehe Discovery-Protokoll) und sendet an diesen die Verbindungsanfrage. Nach erfolgreichem Nachrichten­austausch registrieren beide Seiten die IP-Adresse und den Port des Peers als \texttt{peerAddress} und setzen den Verbindungsstatus auf \texttt{connected = true}; damit werden weitere Verbindungsversuche unterbunden.

\Needspace{8\baselineskip}
\begin{lstlisting}[style=golang, caption={Vereinfachte Behandlung der \texttt{CONNECT\_REQ}-Nachricht (Ausschnitt aus \texttt{handleConnection})}]
if strings.HasPrefix(message, "CONNECT_REQ") {
	if connected == true {
		return // bereits verbunden
	}

	parts := strings.Split(message, ":") // CONNECT_REQ:ip:port
	address := parts[1]
	port := parts[2]
	peerAddress = fmt.Sprintf("%s:%s", address, port)
	connected = true

	conn.Write([]byte("CONNECT_OK"))
	utils.LogInfo("Connected to peer: " + peerAddress)
	return
}
\end{lstlisting}

Bei erfolgreicher Bearbeitung setzt der Server das Feld \texttt{peerAddress} und antwortet mit \texttt{CONNECT\_OK}, woraufhin der Initiator den Verbindungsstatus auf \texttt{connected} setzt und die Discovery-Phase deaktiviert wird.

\section{Backend - Frontend Kommunikation}
Die vom Backend erfassten Zustandsdaten werden mittels Go‑Kanälen an die darstellende Komponente übermittelt. Ein Go‑Channel ist ein typisierter Kommunikationskanal zwischen Goroutinen; in dieser Implementierung werden unpufferte Channels benutzt, d. h. ein Sendevorgang blockiert solange, bis ein Empfänger die Nachricht liest. Das Backend serialisiert periodisch die Struktur \texttt{QueueState} als JSON‑String und sendet diesen über den Nachrichtenkanal an das Frontend; das Frontend konsumiert die eingehenden Nachrichten, deserialisiert sie und aktualisiert die Anzeige. Steuerbefehle des Frontends (etwa ein Verbindungswunsch in Form von \texttt{IP:PORT}) werden über einen separaten Steuerkanal an das Backend übermittelt und dort verarbeitet.

\Needspace{8\baselineskip}
\begin{lstlisting}[style=golang, caption={Backend: Periodisches Senden des \texttt{QueueState} (vereinfacht)}]
func sendQueueStatePeriodically(messageChan chan string, interval time.Duration) {
	for {
		time.Sleep(interval)
		state := QueueState{/* FastQueue, DynamicQueue, SlowQueue, Connected, DiscoveredPeers */}
		data, _ := json.Marshal(state)
		messageChan <- string(data)
	}
}
\end{lstlisting}

\Needspace{8\baselineskip}
\begin{lstlisting}[style=golang, caption={Frontend: Empfang und Verarbeiten der Zustandsnachrichten (vereinfacht)}]
func messageHandler() {
	for msg := range messageChannel {
		var state QueueState
		_ = json.Unmarshal([]byte(msg), &state)
		fyne.Do(func() { updateUI(state) })
	}
}
\end{lstlisting}

\Needspace{8\baselineskip}
\begin{lstlisting}[style=golang, caption={Frontend: Senden eines Verbindungswunsches (vereinfacht)}]
func sendConnectSignalToBackend(address string) {
	signalChan <- address // IP:PORT
}
\end{lstlisting}

\Needspace{8\baselineskip}
\begin{lstlisting}[style=golang, caption={Backend: Empfang von Steuer-Signalen (vereinfacht)}]
go func() {
	for data := range sgnChan {
		if utils.TryToConnectToPeer(data, serverPort) {
			peerAddress = data
			connected = true
		}
	}
}()
\end{lstlisting}

\section{Button-Grid Layout für Peer-Auswahl}
Wie in /ref{frontend-veraenderungen} und \ref{FA-03} erwähnt, wird als zentrale Erweiterung ein Grid-Layout dem Frontend hinzugefügt zur dynamischen Anzeige verbindungsbereiter Peers.
In der alten Version der Anwendung wird dem Benutzer keine Übersicht für verfügbare Peers angezeigt.
Mithilfe der Verwendung von einem \texttt{GridWrapLayout}, wird dies geändert und innerhalb des \texttt{GridWrapLayout} wird pro Peer ein Button hinzugefügt und insgesamt werden alle zusammen als Raster angeordnet.
Im folgenden Code-Block \ref{initialisierung-button-grid} wird die Initialisierung des Grids dargestellt:

\Needspace{8\baselineskip}
\begin{lstlisting}[style=golang, caption={Initialisierung des Button-Grid Containers}]
peersButtonsContainer = container.New(
	layout.NewGridWrapLayout(fyne.NewSize(200, 40))
)
peersButtonsMap = make(map[string]*widget.Button)
\end{lstlisting}\label{initialisierung-button-grid}

Mithilfe des \texttt{GridWrapLayout} werden die Buttons mit einer festgelegten Größe von 200x40 Pixel gerendert und automatisch mit Umbrüchen angeorndet, falls die die aktuelle Breite des Containers nicht ausreicht.
So wird eine responsive Darstellung der Buttons ermöglicht, bei der die Buttons angepasst an die Größe des Anwendungsfensters dem Nutzer bereitgestellt werden.
Wie in \ref{scroll-container} implementiert, wird der \texttt{GridWrapLayout}-Container in einen \texttt{Scroll}-Container mit einer Höhe von 150 Pixel umhüllt, damit die Fenstergröße nicht linear steigt bis in unendliche Größen wie \ref{NFA-08} beschrieben.

\Needspace{6\baselineskip}
\begin{lstlisting}[style=golang, caption={Einbettung in Scroll-Container}]
peersScroll := container.NewVScroll(peersButtonsContainer)
peersScroll.SetMinSize(fyne.NewSize(0, 150))
\end{lstlisting}\label{scroll-container}

Jeder der gerenderten Buttons zur Darstellung der verbindungsbereiten Peers wird mit einem Computer-Icon und der Importance-Stufe \texttt{HighImportance} erstellt.
Somit wird dieser visuell hervorgehoben durch die blaue Farbe und den Kontrast im Standard-Theme.
Mit der Callback-Funktion jedes Buttons wird die jeweilige Kombination aus \texttt{IP-ADRESSE:PORT} über den Signal-Channel \texttt{signalChan} an das Backend geschickt.
Diese Neuerungen werden implementiert im unteren Codeblock \ref{dynamische-button-verwaltung}.

\section{Dynamische Peer-Button-Verwaltung}
Im Frontend wird eine dynamischen Verwaltung der Peer-Buttons im \texttt{GridWrapLayout} hinzugefügt, basierend auf der \texttt{DiscoveredPeers}-Liste vom Backend aus dem Message-Channel (siehe \ref{FA-01}).
Wie in \ref{FA-04} beschrieben, werden nur im nicht verbundenen Zustand neue Peers, die vom Backend erkannt werden, zum Grid-Layout der Peer-Übersicht hinzugefügt und angezeigt.
Außerdem werden verschwundene Peers wieder entfernt, damit diese nicht mehr im Grid-Layout angezeigt werden.
Die schon im Teilkapitel \ref{frontend-veraenderungen} angesprochene Map-Struktur \texttt{peersButtonsMap} wird verwendet, um eine Verbindung zwischen dem Button in Form einer Referenz und der Kombination \texttt{IP-ADRESSE:PORT} zu erschaffen.
Durch den Text im Button wird im Format \texttt{IP-ADRESSE:PORT} die IP-Adresse und der Port des Peers nach \ref{NFA-05} visualisiert.
Diese Umsetzungen können dem folgenden Code-Block \ref{dynamische-button-verwaltung} entnommen werden.

\Needspace{12\baselineskip}
\begin{lstlisting}[style=golang, caption={Dynamische Button-Verwaltung (Ausschnitt aus \texttt{updateUI})}]
if !state.Connected {
	// Neue Peers hinzufügen
	for _, peer := range state.DiscoveredPeers {
		if _, exists := peersButtonsMap[peer]; !exists {
			peerCopy := peer
			btn := widget.NewButtonWithIcon("  "+peerCopy, theme.ComputerIcon(),
				func() { sendConnectSignalToBackend(peerCopy) })
			btn.Importance = widget.HighImportance
			peersButtonsMap[peerCopy] = btn
			peersButtonsContainer.Add(btn)
		}
	}

	// Verschwundene Peers entfernen
	for addr, btn := range peersButtonsMap {
		found := false
		for _, p := range state.DiscoveredPeers {
			if p == addr { found = true; break }
		}
		if !found {
			peersButtonsContainer.Remove(btn)
			delete(peersButtonsMap, addr)
		}
	}
}
\end{lstlisting}\label{dynamische-button-verwaltung}

Ein Button-Closure wird mit der Variable \texttt{peerCopy} verhindert, was ein in Go häufig auftretendes Problem darstellt, bei dem alle Closures auf dieselbe Variable in der Schleife referenzieren würden.
Mit der Erstellung einer Kopie wird die Eindeutigkeit der Variable und das korrekte Anzeigen von IP-Adresse und Port im Button-Text sichergestellt.

\section{Zustandsabhängige UI-Sichtbarkeit}
Die Zustandabhängigkeit der UI wird mit \ref{FA-04} gefordert.
Das Button-Grid-Layout wird im verbundenen Zustand ausgeblendet, damit keine zweite Verbindungsanfrage gesendet werden könnte nach Anforderung \ref{FA-07} und der Disconnect-Button wird eingeblendet.
Im nicht verbundenen Zustand wird dieses Verhalten umgekehrt, das Button-Grid-Layout wird dargestellt und der Disconnect-Button wird temporär entfernt.
Dieses Verhalten wird wie in \ref{zustandabhaengige-ui-aktualisierung} implementiert mithilfe der Abfrage der Variable \texttt{connected} und den Container-spezifischen Methoden \texttt{.Hide()} und \texttt{.Show()}.

\Needspace{10\baselineskip}
\begin{lstlisting}[style=golang, caption={Zustandsabhängige UI-Aktualisierung (Ausschnitt)}]
func updateUI(state QueueState) {
	connected = state.Connected

	if connected {
		disconnectButton.Show()
		peersButtonsContainer.Hide()
		// Alle Peer-Buttons entfernen
		for addr, btn := range peersButtonsMap {
			peersButtonsContainer.Remove(btn)
			delete(peersButtonsMap, addr)
		}
	} else {
		disconnectButton.Hide()
		peersButtonsContainer.Show()
	}

	updateLEDColor(connected)
}
\end{lstlisting}\label{zustandabhaengige-ui-aktualisierung}

Durch den gegenseitige Ausschluss der Darstellung von Disconnect-Button und Button-Grid-Layout werden widersprüchliche Nutzerinteraktionen verhindert und es wird visuelle Eindeutigkeit sichergestellt.
In Codeblock \ref{zustandabhaengige-ui-aktualisierung} wird mit der vollständigen Entfernung aller Buttons, während eine Verbindung erfolgreich hergestellt wird, wird garantiert, dass keine veralteten Buttons von nicht mehr verfügbaren Peers als Artefakte noch im Frontend erhalten bleiben.

\section{Sicherheits- und Netzwerkeffekte}
Das aktive Scanning erzeugt messbaren Netzwerktraffic; in restriktiven Umgebungen kann dies zu Rate-Limiting oder zu Sicherheitswarnungen führen. Die Implementierung ist daher ausschließlich für lokale Netzwerke konzipiert.

